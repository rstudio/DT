# TODO: after the next version of shiny is released, change the error message
# and ask users to install from CRAN instead
checkShinyVersion = function() {
  if (packageVersion('shiny') <= '0.11.1') stop(
    'DT requires shiny > 0.11.1. ',
    'Please install the latest development version of shiny from Github: ',
    'devtools::install_github("rstudio/shiny")'
  )
}

#' Helper functions for using DT in Shiny
#'
#' These two functions are like most \code{fooOutput()} and \code{renderFoo()}
#' functions in the \pkg{shiny} package. The former is used to create a
#' container for table, and the latter is used in the server logic to render the
#' table.
#' @inheritParams shiny::dataTableOutput
#' @param width the width of the table container
#' @param height the height of the table container
#' @references \url{http://rstudio.github.io/DT/shiny.html}
#' @export
#' @examples # !formatR
#' if (interactive()) {
#'   library(shiny)
#'   shinyApp(
#'     ui = fluidPage(fluidRow(column(12, DT::dataTableOutput('tbl')))),
#'     server = function(input, output) {
#'       output$tbl = DT::renderDataTable({
#'         DT::datatable(iris, options = list(lengthChange = FALSE))
#'       })
#'     }
#'   )
#' }
dataTableOutput = function(outputId, width = '100%', height = 'auto') {
  checkShinyVersion()
  htmlwidgets::shinyWidgetOutput(
    outputId, 'datatables', width, height, package = 'DT'
  )
}

#' @export
#' @rdname dataTableOutput
#' @inheritParams shiny::renderDataTable
#' @param expr an expression to create a table widget (normally via
#'   \code{\link{datatable}()})
#' @param ... currently ignored, with a warning message
renderDataTable = function(expr, env = parent.frame(), quoted = FALSE, ...) {
  if (length(list(...))) warning(
    "Arguments in addition to 'expr', 'env', and 'quoted' are ignored. ",
    "If you came from shiny::renderDataTable(), you may want to pass ",
    "these arguments to DT::datatable() instead. See ",
    "http://rstudio.github.io/DT/shiny.html for more info."
  )
  checkShinyVersion()
  if (!quoted) expr = substitute(expr)
  htmlwidgets::shinyRenderWidget(expr, dataTableOutput, env, quoted = TRUE)
}

#' Append a column of checkboxes to the data for selecting rows
#'
#' Append a column of checkboxes with the CSS class \samp{DT checkboxRows} to
#' the data. The checkboxes can be used for selecting rows in Shiny. Each
#' checkbox has a data field \samp{data-row} that contains the index of the
#' current row. The HTML code for checkboxes are generated by
#' \code{checkboxRows()}.
#'
#' For a table output with id \code{foo} in Shiny, the indices of the selected
#' rows are stored in \code{input$foo_selected}.
#' @param data the data to be displayed as the table
#' @param after add the checkboxes after the last column (\code{TRUE}) or before
#'   the first column (\code{FALSE}) of the table
#' @param checked which checkboxes are checked initially (a logical or numeric
#'   vector)
#' @references See \url{http://rstudio.github.io/DT/shiny.html} for examples.
#' @examples library(DT)
#' datatable(appendCheckboxes(iris), escape = -7)
#' @export
appendCheckboxes = function(data, after = TRUE, checked = FALSE) {
  check = checkboxRows(data, checked)
  if (after) cbind(data, ' ' = check) else cbind(' ' = check, data)
}

#' @rdname appendCheckboxes
#' @export
checkboxRows = function(data, checked = FALSE) {
  n = nrow(data)
  s = character(n)
  # we could have generated the checkboxes from tags$input() but it is much
  # slower than the simple sprintf() here; on the other hand, there is no need
  # to escape numbers seq_len(n) since they do not contain special HTML chars
  s[checked] = 'checked '
  sprintf(
    '<input data-row="%s" type="checkbox" class="DT checkboxRows" %s/>',
    seq_len(n), s
  )
}

shinyFun = function(name) getFromNamespace(name, 'shiny')

#' Register a data object in a shiny session for DataTables
#'
#' This function stores a data object in a shiny session and returns a URL that
#' returns JSON data based on DataTables Ajax requests. The URL can be used as
#' the \code{url} option inside the \code{ajax} option of the table. It is
#' basically an implementation of server-side processing of DataTables in R.
#' Filtering, sorting, and pagination are processed through R instead of
#' JavaScript (client-side processing).
#' @param session the \code{session} object in the shiny server function
#'   (\code{function(input, output, session)})
#' @param data a data object (will be coerced to a data frame internally)
#' @param rownames see \code{\link{datatable}()}; it must be consistent with
#'   what you use in \code{datatable()}, e.g. if the widget is generated by
#'   \code{datatable(rownames = FALSE)}, you must also use
#'   \code{dataTableAjax(rownames = FALSE)} here
#' @param filter (for expert use only) a function with two arguments \code{data}
#'   and \code{params} (Ajax parameters, a list of the form \code{list(search =
#'   list(value = 'FOO', regex = 'false'), length = 10, ...)}) that return the
#'   filtered table result according to the DataTables Ajax request
#' @references \url{http://rstudio.github.io/DT/server.html}
#' @return A character string (an Ajax URL that can be queried by DataTables).
#' @example inst/examples/ajax-shiny.R
#' @export
dataTableAjax = function(session, data, rownames, filter = dataTablesFilter) {

  oop = options(stringsAsFactors = FALSE); on.exit(options(oop), add = TRUE)

  # abuse tempfile() to obtain a random id unique to this R session
  id = basename(tempfile(''))

  # deal with row names: rownames = TRUE or missing, use rownames(data)
  rn = if (missing(rownames) || isTRUE(rownames)) base::rownames(data) else {
    if (is.character(rownames)) rownames  # use custom row names
  }
  data = as.data.frame(data)  # think dplyr
  if (length(rn)) data = cbind(' ' = rn, data)

  URLdecode = shinyFun('URLdecode')
  toJSON = shinyFun('toJSON')
  httpResponse = shinyFun('httpResponse')

  filterFun = function(data, req) {
    # DataTables requests were sent via POST
    params = URLdecode(rawToChar(req$rook.input$read()))
    Encoding(params) = 'UTF-8'
    # use system native encoding if possible (again, this grep(fixed = TRUE) bug
    # https://bugs.r-project.org/bugzilla3/show_bug.cgi?id=16264)
    params2 = iconv(params, 'UTF-8', '')
    if (!is.na(params2)) params = params2 else warning(
      'Some DataTables parameters contain multibyte characters ',
      'that do not work in current locale.'
    )
    params = shiny::parseQueryString(params, nested = TRUE)

    res = tryCatch(filter(data, params), error = function(e) {
      list(error = as.character(e))
    })
    httpResponse(200, 'application/json', enc2utf8(toJSON(res)))
  }

  session$registerDataObj(id, data, filterFun)
}

# filter a data frame according to the DataTables request parameters
dataTablesFilter = function(data, params) {
  n = nrow(data)
  q = params
  ci = q$search[['caseInsensitive']] == 'true'

  # global searching
  i = seq_len(n)
  # for some reason, q$search might be NULL, leading to error `if (logical(0))`
  if (isTRUE(q$search[['value']] != '')) {
    i0 = apply(data, 2, function(x) {
      grep2(q$search[['value']], as.character(x),
            fixed = q$search[['regex']] == 'false', ignore.case = ci)
    })
    i = intersect(i, unique(unlist(i0)))
  }

  # search by columns
  if (length(i)) for (j in names(q$columns)) {
    col = q$columns[[j]]
    # if the j-th column is not searchable or the search string is "", skip it
    if (col[['searchable']] != 'true') next
    if ((k <- col[['search']][['value']]) == '') next
    j = as.integer(j)
    dj = data[, j + 1]
    ij = if (is.numeric(dj) || is.Date(dj)) {
      r = commaToRange(k)
      if (length(r) != 2)
        stop('The range of a numeric / date / time column must be of length 2')
      if (is.Date(dj)) {
        # r is milliseconds
        r = as.POSIXct(r / 1000, origin = '1970-01-01')
        if (inherits(dj, 'Date')) r = as.Date(r)
      }
      which(dj >= r[1] & dj <= r[2])
    } else if (is.factor(dj)) {
      which(dj %in% jsonlite::fromJSON(k))
    } else {
      grep2(k, as.character(dj), fixed = col[['search']][['regex']] == 'false',
            ignore.case = ci)
    }
    i = intersect(ij, i)
    if (length(i) == 0) break
  }
  if (length(i) != n) data = data[i, , drop = FALSE]

  # sorting
  oList = list()
  for (ord in q$order) {
    k = ord[['column']]  # which column to sort
    d = ord[['dir']]     # direction asc/desc
    if (q$columns[[k]][['orderable']] != 'true') next
    col = data[, as.integer(k) + 1]
    oList[[length(oList) + 1]] = (if (d == 'asc') identity else `-`)(
      if (is.numeric(col)) col else xtfrm(col)
    )
  }
  if (length(oList)) {
    i = do.call(order, oList)
    data = data[i, , drop = FALSE]
  }
  # paging
  if (q$length != '-1') {
    i = seq(as.integer(q$start) + 1L, length.out = as.integer(q$length))
    i = i[i <= nrow(data)]
    fdata = data[i, , drop = FALSE]  # filtered data
  } else fdata = data

  fdata = unname(as.matrix(fdata))
  if (is.character(fdata) && q$escape != 'false') {
    if (q$escape == 'true') fdata = htmlEscape(fdata) else {
      k = as.integer(strsplit(q$escape, ',')[[1]])
      # use seq_len() in case escape = negative indices, e.g. c(-1, -5)
      for (j in seq_len(ncol(fdata))[k]) fdata[, j] = htmlEscape(fdata[, j])
    }
  }

  list(
    draw = as.integer(q$draw),
    recordsTotal = n,
    recordsFiltered = nrow(data),
    data = fdata
  )
}

# when both ignore.case and fixed are TRUE, we use grep(ignore.case = FALSE,
# fixed = TRUE) to do lower-case matching of pattern on x
grep2 = function(pattern, x, ignore.case = FALSE, fixed = FALSE, ...) {
  if (fixed && ignore.case) {
    pattern = tolower(pattern)
    x = tolower(x)
    ignore.case = FALSE
  }
  # when the user types in the search box, the regular expression may not be
  # complete before it is sent to the server, in which case we do not search
  if (!fixed && inherits(try(grep(pattern, ''), silent = TRUE), 'try-error'))
    return(seq_along(x))
  grep(pattern, x, ignore.case = ignore.case, fixed = fixed, ...)
}

# convert a string of the form "lower,upper" to c(lower, upper)
commaToRange = function(string) {
  if (!grepl(',', string)) return()
  r = strsplit(string, ',')[[1]]
  if (length(r) > 2) return()
  if (length(r) == 1) r = c(r, '')  # lower,
  r = as.numeric(r)
  if (is.na(r[1])) r[1] = -Inf
  if (is.na(r[2])) r[2] = Inf
  r
}
